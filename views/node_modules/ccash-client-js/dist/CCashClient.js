"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CCashClient = void 0;
const axios_1 = require("axios");
const class_validator_1 = require("class-validator");
const debug_1 = require("debug");
const responses_1 = require("./responses");
const exceptions_1 = require("./exceptions");
const log = debug_1.default('CCashClient');
function LogCall(target, propertyKey, descriptor) {
    const original = descriptor.value;
    descriptor.value = function (...args) {
        log(`call ${propertyKey}`);
        return original.apply(this, args);
    };
}
class CCashClient {
    constructor(baseURL = process.env.CCASH_API_BASE_URL) {
        if (!baseURL) {
            throw new exceptions_1.BaseUrlMissingException();
        }
        this.http = axios_1.default.create({
            baseURL,
        });
    }
    balance(user) {
        return this.http
            .get(`/${user}/bal`)
            .then((response) => __awaiter(this, void 0, void 0, function* () { return yield this.handleResponse(response); }));
    }
    log(user, password) {
        return this.http
            .get(`/${user}/log`, {
            headers: { Password: password },
        })
            .then((response) => this.handleResponse(response, responses_1.LogResponseValidator));
    }
    sendFunds(user, password, to, amount) {
        return this.http
            .post(`/${user}/send/${to}`, undefined, {
            headers: { Password: password },
            params: { amount: amount },
        })
            .then((response) => this.handleResponse(response));
    }
    verifyPassword(user, password) {
        return this.http
            .get(`/${user}/pass/verify`, { headers: { Password: password } })
            .then((response) => this.handleResponse(response));
    }
    changePassword(user, password, newPassword) {
        return this.http
            .patch(`/${user}/pass/change`, newPassword, {
            headers: { Password: password },
        })
            .then((response) => this.handleResponse(response));
    }
    setBalance(user, password, amount) {
        return this.http
            .patch(`/admin/${user}/bal`, undefined, {
            headers: { Password: password },
            params: { amount: amount },
        })
            .then((response) => this.handleResponse(response));
    }
    help() {
        return this.http
            .get('/help')
            .then((response) => this.handleResponse(response, responses_1.StringResponseValidator));
    }
    ping() {
        return this.http
            .get('/ping')
            .then((response) => this.handleResponse(response, responses_1.StringResponseValidator));
    }
    close(password) {
        return this.http
            .post('/close', undefined, { headers: { Password: password } })
            .then((response) => this.handleResponse(response));
    }
    contains(user) {
        return this.http
            .get(`/contains/${user}`)
            .then((response) => this.handleResponse(response));
    }
    adminVerifyPassword(password) {
        return this.http
            .get('/admin/verify', { headers: { Password: password } })
            .then((response) => this.handleResponse(response));
    }
    addUser(user, password) {
        return this.http
            .post(`/user/${user}`, undefined, { headers: { Password: password } })
            .then((response) => this.handleResponse(response));
    }
    adminAddUser(user, password, initialPassword, initialBalance) {
        return this.http
            .post(`/admin/user/${user}`, initialPassword, {
            headers: { Password: password },
            params: { init_bal: initialBalance },
        })
            .then((response) => this.handleResponse(response));
    }
    deleteUser(user, password) {
        return this.http
            .delete(`/user/${user}`, { headers: { Password: password } })
            .then((response) => this.handleResponse(response));
    }
    adminDeleteUser(user, password) {
        return this.http
            .delete(`/admin/user/${user}`, { headers: { Password: password } })
            .then((response) => this.handleResponse(response));
    }
    handleResponse(response, Validator = responses_1.NumberResponseValidator) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            log('response:', response.data);
            log('validator:', Validator);
            const value = (_b = (_a = response.data) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : response.data;
            typeof value === 'number' && this.handleExceptions(value);
            const errors = yield class_validator_1.validate(new Validator({ value }));
            if (errors.length > 0) {
                throw new exceptions_1.InvalidResponseException(errors);
            }
            return value;
        });
    }
    handleExceptions(value) {
        if (value && Object.values(exceptions_1.ExceptionCodes).includes(value)) {
            throw new exceptions_1.ExceptionMap[value]();
        }
    }
}
__decorate([
    LogCall
], CCashClient.prototype, "balance", null);
__decorate([
    LogCall
], CCashClient.prototype, "log", null);
__decorate([
    LogCall
], CCashClient.prototype, "sendFunds", null);
__decorate([
    LogCall
], CCashClient.prototype, "verifyPassword", null);
__decorate([
    LogCall
], CCashClient.prototype, "changePassword", null);
__decorate([
    LogCall
], CCashClient.prototype, "setBalance", null);
__decorate([
    LogCall
], CCashClient.prototype, "help", null);
__decorate([
    LogCall
], CCashClient.prototype, "ping", null);
__decorate([
    LogCall
], CCashClient.prototype, "close", null);
__decorate([
    LogCall
], CCashClient.prototype, "contains", null);
__decorate([
    LogCall
], CCashClient.prototype, "adminVerifyPassword", null);
__decorate([
    LogCall
], CCashClient.prototype, "addUser", null);
__decorate([
    LogCall
], CCashClient.prototype, "adminAddUser", null);
__decorate([
    LogCall
], CCashClient.prototype, "deleteUser", null);
__decorate([
    LogCall
], CCashClient.prototype, "adminDeleteUser", null);
exports.CCashClient = CCashClient;
